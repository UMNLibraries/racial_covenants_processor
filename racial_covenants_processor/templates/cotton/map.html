{% load static %}
<c-vars sidebar="" geoman="" pmtiles_url="" />

<div x-data="mapApp({ geoman: '{{ geoman }}' === 'true', pmtilesUrl: '{{ pmtiles_url }}' })" x-init="initMap()" style="display: flex; height: 50vh">
    <!-- Map Container -->
    <div style="width: 100%; position: relative;">
        <div id="map" style="width: 100%; height: 100%"></div>
    </div>

    {% if sidebar == "true" %}
    <div class="map-sidebar">
        <template x-if="selectedFeatures.length === 0 && !hoveredFeature">
            <div class="stack gap-s">
                <p class="muted size-s">Click a parcel to view covenant details.</p>
                <p class="muted size-xs">Hold Cmd/Ctrl to select multiple parcels.</p>
            </div>
        </template>

        <template x-if="selectedFeatures.length > 0">
            <div class="stack gap-m">
                <div class="split align-center">
                    <strong class="size-s">Selected (<span x-text="selectedFeatures.length"></span>)</strong>
                    <button type="button" @click="clearAllSelections()" class="btn outline size-xs">Clear</button>
                </div>
                <template x-for="(feature, index) in selectedFeatures" :key="feature.properties?.db_id || index">
                    <div class="callout stack gap-s">
                        <div>
                            <strong x-text="feature.properties?.street_add || 'No address'"></strong>
                            <div class="size-xs muted" x-text="[feature.properties?.city, feature.properties?.state].filter(Boolean).join(', ') || ''"></div>
                        </div>
                        <hr>
                        <div class="stack gap-2xs size-xs">
                            <div class="split">
                                <span class="muted">Deed date</span>
                                <span x-text="formatDate(feature.properties?.deed_date)"></span>
                            </div>
                            <div class="split">
                                <span class="muted">Addition</span>
                                <span x-text="feature.properties?.add_cov || '—'"></span>
                            </div>
                            <div class="split">
                                <span class="muted">Lot / Block</span>
                                <span x-text="[feature.properties?.lot_cov, feature.properties?.block_cov].filter(Boolean).join(' / ') || '—'"></span>
                            </div>
                            <div class="split">
                                <span class="muted">Seller</span>
                                <span x-text="feature.properties?.seller || '—'"></span>
                            </div>
                            <div class="split">
                                <span class="muted">Buyer</span>
                                <span x-text="feature.properties?.buyer || '—'"></span>
                            </div>
                            <div class="split">
                                <span class="muted">Doc #</span>
                                <span x-text="feature.properties?.doc_num || '—'"></span>
                            </div>
                            <div class="split">
                                <span class="muted">PIN</span>
                                <span x-text="feature.properties?.cnty_pin || '—'"></span>
                            </div>
                        </div>
                        <template x-if="feature.properties?.cov_text">
                            <details class="size-xs">
                                <summary>Covenant text</summary>
                                <p class="muted" style="white-space: pre-wrap; margin-top: 0.5em;" x-text="feature.properties?.cov_text"></p>
                            </details>
                        </template>
                    </div>
                </template>
            </div>
        </template>

        <template x-if="hoveredFeature && selectedFeatures.length === 0">
            <div class="callout stack gap-s">
                <div>
                    <strong x-text="hoveredFeature.properties?.street_add || 'No address'"></strong>
                    <div class="size-xs muted" x-text="[hoveredFeature.properties?.city, hoveredFeature.properties?.state].filter(Boolean).join(', ') || ''"></div>
                </div>
                <hr>
                <div class="stack gap-2xs size-xs">
                    <div class="split">
                        <span class="muted">Deed date</span>
                        <span x-text="formatDate(hoveredFeature.properties?.deed_date)"></span>
                    </div>
                    <div class="split">
                        <span class="muted">Addition</span>
                        <span x-text="hoveredFeature.properties?.add_cov || '—'"></span>
                    </div>
                    <div class="split">
                        <span class="muted">Lot / Block</span>
                        <span x-text="[hoveredFeature.properties?.lot_cov, hoveredFeature.properties?.block_cov].filter(Boolean).join(' / ') || '—'"></span>
                    </div>
                </div>
            </div>
        </template>
    </div>
    <style>
        .map-sidebar {
            width: 20em;
            padding: 1em;
            overflow-y: auto;
            background: var(--surface-1, #fff);
            border-left: 1px solid var(--border, #e5e5e5);
        }
    </style>
    {% endif %}
</div>
<script>
function mapApp(options = {}) {
  return {
    map: null,
    geoman: null,
    geomanEnabled: options.geoman || false,
    pmtilesUrl: options.pmtilesUrl || "",
    sourceLayer: null,
    hoveredFeatureId: null,
    selectedFeatureIds: new Set(),
    selectedFeatures: [],
    hoveredFeature: null,
    gmEvents: [],
    expandedGeoJsonIndex: -1,
    isAnyGeomanModeActive: false,
    measurementPopup: null,
    isDrawingMode: false,
    currentDrawingCoordinates: [],
    drawingShape: null,

    /**
     * Format ISO date string to readable format
     */
    formatDate(dateStr) {
      if (!dateStr) return '—';
      const date = new Date(dateStr);
      if (isNaN(date)) return dateStr;
      return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
    },

    /**
     * Initialize the map and all event listeners
     * Called by Alpine.js x-init directive
     */
    async initMap() {
      // Initialize PMTiles protocol
      const protocol = new pmtiles.Protocol();
      maplibregl.addProtocol("pmtiles", protocol.tile);

      // Get PMTiles metadata to determine bounds and source layer
      const pm = new pmtiles.PMTiles(this.pmtilesUrl);
      const header = await pm.getHeader();
      const metadata = await pm.getMetadata();
      this.sourceLayer = metadata.vector_layers[0].id;

      // Create map and fit to PMTiles bounds
      this.map = new maplibregl.Map({
        container: "map",
        style: this.getMapStyle(),
        bounds: [[header.minLon, header.minLat], [header.maxLon, header.maxLat]],
        fitBoundsOptions: { padding: 20 },
        fadeDuration: 50,
        minZoom: 0,
        maxZoom: 18,
      });

      // Initialize Geoman if enabled
      if (this.geomanEnabled) {
        const gmOptions = {
          controls: {
            helper: {
              snapping: {
                uiEnabled: true,
                active: false,
              },
            },
          },
        };
        this.geoman = new window.Geoman.Geoman(this.map, gmOptions);
      }

      // Setup event listeners
      this.map.on("load", () => {
        this.setupMapListeners();
        if (this.geomanEnabled) {
          this.setupGeomanListeners();
        }
        this.checkPlatQueryParam();
      });

      this.map.on("error", (e) => {
        console.error("Map error:", e);
      });
    },

    /**
     * Define the MapLibre style specification
     */
    getMapStyle() {
      return {
        version: 8,
        glyphs: "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
        sources: {
          "osm-tiles": {
            type: "raster",
            tiles: ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
            tileSize: 256,
            attribution: "© OpenStreetMap contributors",
          },
          protomaps: {
            type: "vector",
            url: `pmtiles://${this.pmtilesUrl}`,
            promoteId: "db_id",
          },
        },
        layers: [
          {
            id: "osm-tiles-layer",
            type: "raster",
            source: "osm-tiles",
            minzoom: 0,
            maxzoom: 19,
          },
          {
            id: "pmtiles-fill-default",
            source: "protomaps",
            "source-layer": this.sourceLayer,
            type: "fill",
            paint: {
              "fill-color": [
                "case",
                ["boolean", ["feature-state", "selected"], false],
                "rgba(0, 100, 255, 0.7)",
                ["boolean", ["feature-state", "hover"], false],
                "rgba(255, 0, 0, 0.7)",
                "rgba(255, 0, 0, 0.3)",
              ],
              "fill-outline-color": [
                "case",
                ["boolean", ["feature-state", "selected"], false],
                "#0064ff",
                "#ff0000",
              ],
            },
            minzoom: 0,
            maxzoom: 18,
          },
        ],
      };
    },

    /**
     * Setup map event listeners for hover and click interactions
     */
    setupMapListeners() {
      // Mouse move handler
      this.map.on("mousemove", (e) => {
        // Handle live drawing measurements
        if (this.isDrawingMode) {
          this.showLiveDrawingMeasurement([e.lngLat.lng, e.lngLat.lat]);
        }

        // Skip feature hover when Geoman mode is active
        if (this.isAnyGeomanModeActive) {
          if (this.hoveredFeatureId !== null) {
            this.clearHover();
          }
          return;
        }

        const features = this.map.queryRenderedFeatures(e.point, {
          layers: ["pmtiles-fill-default"],
        });

        if (features.length > 0) {
          const feature = features[0];
          const featureId = feature.properties?.db_id || feature.id;

          if (featureId !== this.hoveredFeatureId) {
            if (this.hoveredFeatureId !== null) {
              this.map.setFeatureState(
                {
                  source: "protomaps",
                  sourceLayer: this.sourceLayer,
                  id: this.hoveredFeatureId,
                },
                { hover: false }
              );
            }

            this.map.setFeatureState(
              {
                source: "protomaps",
                sourceLayer: this.sourceLayer,
                id: featureId,
              },
              { hover: true }
            );

            this.hoveredFeatureId = featureId;
            this.hoveredFeature = feature;
            this.map.getCanvas().style.cursor = "pointer";
          }
        } else {
          if (this.hoveredFeatureId !== null) {
            this.clearHover();
          }
        }
      });

      // Click handler for feature selection
      this.map.on("click", (e) => {
        // Track coordinates during drawing
        if (this.isDrawingMode) {
          this.currentDrawingCoordinates.push([e.lngLat.lng, e.lngLat.lat]);
          return;
        }

        // Skip selection when Geoman mode is active
        if (this.isAnyGeomanModeActive) {
          return;
        }

        const features = this.map.queryRenderedFeatures(e.point, {
          layers: ["pmtiles-fill-default"],
        });

        if (features.length > 0) {
          const feature = features[0];
          const featureId = feature.properties?.db_id || feature.id;
          const isCtrlOrCmd =
            e.originalEvent.ctrlKey || e.originalEvent.metaKey;

          if (isCtrlOrCmd) {
            // Multi-select mode
            if (this.selectedFeatureIds.has(featureId)) {
              // Deselect
              this.selectedFeatureIds.delete(featureId);
              this.selectedFeatures = this.selectedFeatures.filter(
                (f) => (f.properties?.db_id || f.id) !== featureId
              );
              this.map.setFeatureState(
                {
                  source: "protomaps",
                  sourceLayer: this.sourceLayer,
                  id: featureId,
                },
                { selected: false }
              );
            } else {
              // Add to selection
              this.selectedFeatureIds.add(featureId);
              this.selectedFeatures.push(feature);
              this.map.setFeatureState(
                {
                  source: "protomaps",
                  sourceLayer: this.sourceLayer,
                  id: featureId,
                },
                { selected: true }
              );
            }
          } else {
            // Single select mode
            this.clearAllSelections();
            this.selectedFeatureIds.add(featureId);
            this.selectedFeatures = [feature];
            this.map.setFeatureState(
              {
                source: "protomaps",
                sourceLayer: this.sourceLayer,
                id: featureId,
              },
              { selected: true }
            );
          }
        } else {
          // Clear selection when clicking empty area
          if (!e.originalEvent.ctrlKey && !e.originalEvent.metaKey) {
            this.clearAllSelections();
          }
        }
      });
    },

    /**
     * Setup Geoman event listeners for drawing and editing
     */
    setupGeomanListeners() {
      this.map.on("gm:globaldrawmodetoggled", (e) => {
        this.isAnyGeomanModeActive = e.enabled;
        this.isDrawingMode = e.enabled;

        if (e.enabled) {
          this.currentDrawingCoordinates = [];
          this.drawingShape = e.shape || null;
        } else {
          this.isDrawingMode = false;
          this.currentDrawingCoordinates = [];
          this.drawingShape = null;
          this.hideMeasurementPopup();
        }

        this.logEvent(e);
      });

      this.map.on("gm:globaleditmodetoggled", (e) => {
        this.isAnyGeomanModeActive = e.enabled;
        this.logEvent(e);
      });

      this.map.on("gm:globalremovemodetoggled", (e) => {
        this.isAnyGeomanModeActive = e.enabled;
        this.logEvent(e);
      });

      this.map.on("gm:globalrotatemodetoggled", (e) => {
        this.isAnyGeomanModeActive = e.enabled;
        this.logEvent(e);
      });

      this.map.on("gm:globaldragmodetoggled", (e) => {
        this.isAnyGeomanModeActive = e.enabled;
        this.logEvent(e);
      });

      this.map.on("gm:globalcutmodetoggled", (e) => {
        this.isAnyGeomanModeActive = e.enabled;
        this.logEvent(e);
      });

      this.map.on("gm:create", (e) => {
        this.isDrawingMode = false;
        this.currentDrawingCoordinates = [];
        this.drawingShape = null;
        this.logEvent(e);
        this.handleMeasurementForFeature(e);
      });

      this.map.on("gm:editstart", (e) => {
        this.logEvent(e);
        this.hideMeasurementPopup();
      });

      this.map.on("gm:editend", (e) => {
        this.logEvent(e);
        this.handleMeasurementForFeature(e);
      });

      this.map.on("gm:remove", (e) => {
        this.logEvent(e);
        this.hideMeasurementPopup();
      });

      this.map.on("gm:dragstart", (e) => {
        this.logEvent(e);
        this.hideMeasurementPopup();
      });

      this.map.on("gm:dragend", (e) => {
        this.logEvent(e);
        this.handleMeasurementForFeature(e);
      });
    },

    /**
     * Clear hovered feature state
     */
    clearHover() {
      if (this.hoveredFeatureId !== null) {
        this.map.setFeatureState(
          {
            source: "protomaps",
            sourceLayer: this.sourceLayer,
            id: this.hoveredFeatureId,
          },
          { hover: false }
        );
        this.hoveredFeatureId = null;
        this.hoveredFeature = null;
        this.map.getCanvas().style.cursor = "";
      }
    },

    /**
     * Clear all selected features
     */
    clearAllSelections() {
      for (const id of this.selectedFeatureIds) {
        this.map.setFeatureState(
          {
            source: "protomaps",
            sourceLayer: this.sourceLayer,
            id: id,
          },
          { selected: false }
        );
      }
      this.selectedFeatureIds.clear();
      this.selectedFeatures = [];
    },

    /**
     * Log Geoman events to the sidebar
     */
    logEvent(e) {
      const eventData = {
        id: e.feature?.id || Date.now(),
        timestamp: new Date().toISOString(),
        type: e.type,
        shape: e.shape,
        enabled: e.enabled,
      };

      // Extract GeoJSON for create events
      if (
        e.type === "gm:create" &&
        e.feature?.source?.sourceInstance?._data?.features
      ) {
        const features = e.feature.source.sourceInstance._data.features;
        if (features.length > 0) {
          eventData.geojson = JSON.stringify(
            features[features.length - 1],
            null,
            2
          );
        }
      }

      this.gmEvents.unshift(eventData);
    },

    /**
     * Toggle GeoJSON display for an event
     */
    toggleGeoJson(index) {
      this.expandedGeoJsonIndex =
        this.expandedGeoJsonIndex === index ? -1 : index;
    },

    /**
     * Format distance in meters or kilometers
     */
    formatDistance(meters) {
      if (meters < 1000) {
        return `${meters.toFixed(2)} m`;
      }
      return `${(meters / 1000).toFixed(2)} km`;
    },

    /**
     * Format area in square meters or hectares
     */
    formatArea(squareMeters) {
      if (squareMeters < 10000) {
        return `${squareMeters.toFixed(2)} m²`;
      }
      return `${(squareMeters / 10000).toFixed(2)} ha`;
    },

    /**
     * Show measurement popup for a feature
     */
    showMeasurementPopup(feature, lngLat) {
      let measurement = "";

      if (feature.geometry.type === "LineString") {
        const distance = turf.length(feature, { units: "meters" });
        measurement = `Distance: ${this.formatDistance(distance)}`;
      } else if (feature.geometry.type === "Polygon") {
        const area = turf.area(feature);
        const perimeter = turf.length(turf.polygonToLine(feature), {
          units: "meters",
        });
        measurement = `Area: ${this.formatArea(
          area
        )}<br/>Perimeter: ${this.formatDistance(perimeter)}`;
      }

      if (measurement) {
        this.hideMeasurementPopup();
        this.measurementPopup = new maplibregl.Popup({
          closeButton: false,
          closeOnClick: false,
          className: "measurement-popup",
        })
          .setLngLat(lngLat)
          .setHTML(
            `<div style="font-size: 12px; padding: 4px;">${measurement}</div>`
          )
          .addTo(this.map);
      }
    },

    /**
     * Hide measurement popup
     */
    hideMeasurementPopup() {
      if (this.measurementPopup) {
        this.measurementPopup.remove();
        this.measurementPopup = null;
      }
    },

    /**
     * Show live measurements while drawing
     */
    showLiveDrawingMeasurement(mouseCoords) {
      if (!this.isDrawingMode || this.currentDrawingCoordinates.length === 0)
        return;

      const coords = [...this.currentDrawingCoordinates, mouseCoords];
      let measurement = "";

      if (this.drawingShape === "line" || this.drawingShape === "Line") {
        if (coords.length >= 2) {
          const lineFeature = {
            type: "Feature",
            properties: {},
            geometry: {
              type: "LineString",
              coordinates: coords,
            },
          };
          const distance = turf.length(lineFeature, { units: "meters" });
          measurement = `Distance: ${this.formatDistance(distance)}`;
        }
      } else if (
        this.drawingShape === "polygon" ||
        this.drawingShape === "Polygon"
      ) {
        if (coords.length >= 3) {
          const closedCoords = [...coords, coords[0]];
          const polygonFeature = {
            type: "Feature",
            properties: {},
            geometry: {
              type: "Polygon",
              coordinates: [closedCoords],
            },
          };
          const area = turf.area(polygonFeature);
          const perimeter = turf.length(turf.polygonToLine(polygonFeature), {
            units: "meters",
          });
          measurement = `Area: ${this.formatArea(
            area
          )}<br/>Perimeter: ${this.formatDistance(perimeter)}`;
        } else if (coords.length >= 2) {
          const lineFeature = {
            type: "Feature",
            properties: {},
            geometry: {
              type: "LineString",
              coordinates: coords,
            },
          };
          const distance = turf.length(lineFeature, { units: "meters" });
          measurement = `Distance: ${this.formatDistance(distance)}`;
        }
      }

      if (measurement) {
        this.hideMeasurementPopup();
        this.measurementPopup = new maplibregl.Popup({
          closeButton: false,
          closeOnClick: false,
          className: "measurement-popup",
        })
          .setLngLat(mouseCoords)
          .setHTML(
            `<div style="font-size: 12px; padding: 4px;">${measurement}</div>`
          )
          .addTo(this.map);
      }
    },

    /**
     * Handle measurements for completed features
     */
    handleMeasurementForFeature(e) {
      if (e.feature?.source?.sourceInstance?._data?.features) {
        const features = e.feature.source.sourceInstance._data.features;
        if (features.length > 0) {
          const feature = features[features.length - 1];
          if (
            feature.geometry.type === "LineString" ||
            feature.geometry.type === "Polygon"
          ) {
            const coords = feature.geometry.coordinates;
            let lngLat;

            if (feature.geometry.type === "LineString") {
              lngLat = coords[coords.length - 1];
            } else {
              const center = turf.centroid(feature);
              lngLat = center.geometry.coordinates;
            }

            this.showMeasurementPopup(feature, lngLat);
          }
        }
      }
    },

    /**
     * Check for plat query parameter and center map
     */
    checkPlatQueryParam() {
      const urlParams = new URLSearchParams(window.location.search);
      const platParam = urlParams.get("plat");
      if (platParam) {
        this.searchAndCenterOnPlat(platParam);
      }
    },

    /**
     * Search for parcels by plat value and center map
     */
    searchAndCenterOnPlat(platValue) {
      if (!this.map.isStyleLoaded()) {
        this.map.on("styledata", () => {
          this.searchAndCenterOnPlat(platValue);
        });
        return;
      }

      const features = this.map.querySourceFeatures("protomaps", {
        sourceLayer: this.sourceLayer,
      });

      const matchingFeatures = features.filter(
        (feature) => feature.properties?.Plat === platValue
      );

      if (matchingFeatures.length > 0) {
        const bounds = new maplibregl.LngLatBounds();

        for (const feature of matchingFeatures) {
          if (feature.geometry.type === "Polygon") {
            for (const coord of feature.geometry.coordinates[0]) {
              bounds.extend(coord);
            }
          } else if (feature.geometry.type === "MultiPolygon") {
            for (const polygon of feature.geometry.coordinates) {
              for (const coord of polygon[0]) {
                bounds.extend(coord);
              }
            }
          }
        }

        this.map.fitBounds(bounds, {
          padding: 50,
          zoom: 16,
        });
      } else {
        console.warn(`No features found with plat value: ${platValue}`);
      }
    },

    /**
     * Save covenant - integrate with Django backend
     */
    saveCovenant() {
      console.log("Save covenant clicked");
      console.log("Selected features:", this.selectedFeatures);
      console.log("Events:", this.gmEvents);
    },
  };
}
</script>

<link rel="stylesheet" href="https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.css">
<script src="https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.js"></script>
<link rel="stylesheet" href="https://unpkg.com/@geoman-io/maplibre-geoman-free@latest/dist/maplibre-geoman.css">
<script src="https://unpkg.com/@geoman-io/maplibre-geoman-free@latest/dist/maplibre-geoman.umd.js"></script>
<script src="https://unpkg.com/pmtiles@3.0.7/dist/pmtiles.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>